{# Import statements#}
import os

from hsml.client.exceptions import ModelServingException
from hsml.deployment import Deployment
from hsml.model import Model

{% if modeL_type == MODEL.FRAMEWORK_PYTHON %}
import numpy as np
import pandas as pd
{% endif %}

{% if modeL_type == MODEL.FRAMEWORK_PYTHON %}
import numpy as np
{% endif %}

{# PATCH MUST BE REMOVED #}
# PATCH MUST BE REMOVED
import nest_asyncio
nest_asyncio.apply()

{# Class definition #}
class Predictor:
    {% if async_logger %}
    def __init__(self, deployment : Deployment, model : Model, async_logger):
    {% else %}
    def __init__(self, deployment : Deployment, model : Model):
    {% endif %}
        # Initializes the serving state, reads a trained model

        # The hopsworks model
        self.hopsworks_model = model

        # load the model
        try:
            self.model = self.load(os.environ["MODEL_FILES_PATH"])
        except Exception as e:
            raise ModelServingException(f"Could not load saved model for deployment `{deployment.name}`. Please check if model `{deployment.model_name}` was saved using the default save function. \
                                        If the model was saved using other mean please write your own predict script or override the `load_model` function.") from e

        if not self.model:
            raise ModelServingException(f"Could not load saved model for deployment `{deployment.name}`. Please check if model `{deployment.model_name}` was saved using the default save function. \
                                        If the model was saved using other mean please write your own predict script or override the `load_model` function.")

        # Get feature view and initialize serving
        {# If feature logging required split initlize serving with the provided logger #}
        {% if async_logger %}
        self.feature_view = model.get_feature_view(init=False)
        self.feature_view.init_serving(training_dataset_version=model.training_dataset_version, feature_logger=async_logger)
        self.feature_logger = async_logger
        {% else %}
        self.feature_view = model.get_feature_view(init=True)
        {% endif %}


    def load(self, save_directory : str):
        # Load a model saved in the Hopsworks model registery
        return self.hopsworks_model.load(path=None)

    @staticmethod
    def build_feature_vector_request_from_dict(data: dict):
        # Serving keys required for reading features vectors from the feature view.
        entries = {
        {%for feature in deployemnt_schema.serving_keys %}
            "{{ feature }}" : data["{{ feature }}"],
        {% endfor %}
        }

        # Passed features required to be used while featching feature vectors.
        passed_features = {
        {%for feature in deployemnt_schema.passed_features %}
            "{{ feature }}" : data["{{ feature }}"],
        {% endfor %}
        }

        # Request Parameters required for fetching feature vectors.
        request_parameters = {
        {%for feature in deployemnt_schema.request_parameters %}
            "{{ feature }}" : data["{{ feature }}"],
        {% endfor %}
        }

        return entries, passed_features, request_parameters

    @staticmethod
    def build_feature_vector_request_from_list(data: list):
        # Serving keys required for reading features vectors from the feature view.
        entries = {
        {%for feature in deployemnt_schema.serving_keys %}
            "{{ feature }}" : data[{{ loop.index0 }}],
        {% endfor %}
        }

        # Passed features required to be used while featching feature vectors.
        passed_features = {
        {%for feature in deployemnt_schema.passed_features %}
            "{{ feature }}" : data[{{ deployemnt_schema.serving_keys | length + loop.index0 }}],
        {% endfor %}
        }

        # Request Parameters required for fetching feature vectors.
        request_parameters = {
        {%for feature in deployemnt_schema.request_parameters %}
            "{{ feature }}" : data[{{ deployemnt_schema.serving_keys | length + deployemnt_schema.passed_features | length + loop.index0 }}],
        {% endfor %}
        }

        return entries, passed_features, request_parameters

    def predict(self, inputs):
        # Serving keys required for reading features vectors from the feature view.
        entries = []
        passed_features = []
        request_parameters = []
        for data in inputs:
            if isinstance(data, list):
                entry, passed_feature, request_parameter = Predictor.build_feature_vector_request_from_list(data)
            elif isinstance(data, dict):
                entry, passed_feature, request_parameter = Predictor.build_feature_vector_request_from_dict(data)
            else:
                raise ModelServingException(f"Cannot extract the required data from passed input. Ensure that the input data is a list of lists or a list of dictionaries and the each element follows the deployment schema.") from e
            entries.append(entry)
            passed_features.append(passed_feature)
            request_parameters.append(request_parameter)

        # Fetch feature vector
        untransformed_feature_vectors = self.feature_view.get_feature_vectors(entry=entries, passed_features=passed_features, request_parameters=request_parameters, transform=False)
        feature_vectors = self.feature_view.transform(untransformed_feature_vectors)

        # Making predictions
        {# If model schema matches the features in the feature view. Use model to make predictions directly #}
        {% if model_schema.input_features == feature_view_features %}
        predictions = self.model.predict([feature_vectors])
        {# Else try extracting the required feature from the returned feature vector, the script itself would not be created if any features in the model schema are not in the featue view. #}
        {% else %}
        model_inputs = [
        {% for feature in model_schema.input_features %}
            feature_vectors[0]{{ [feature_view_features.index(feature)] }},
        {% endfor %}
        ]

        predictions = self.model.predict(model_inputs)
        {% endif %}

        {% if async_logger %}

        # Logging features
        self.feature_logger.log(untransformed_feature_vectors, feature_vectors, predictions)

        {% endif %}

        {% if modeL_type == MODEL.FRAMEWORK_PYTHON %}
        {# Assuming that the return type of a transformation functions can be either a list, a numpy array, pandas DataFrame / Series #}
        if isinstance(predictions, np.ndarray):
            predictions = predictions.tolist()
        elif isinstance(predictions, pd.DataFrame):
            predictions = predictions.to_dict(orient="records")
        elif isinstance(predictions, pd.Series):
            predictions = predictions.to_list()
        {% endif %}

        {% if modeL_type == MODEL.FRAMEWORK_SKLEARN %}
        predictions = predictions.tolist()
        {% endif %}

        return predictions